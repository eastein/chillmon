#!/usr/bin/env python

import RPi.GPIO as GPIO
import mcp3008
import mediorc
import sys
import time

CHILLPIN = 17

def nv(v) :
	if v is None :
		return 0.0
	else :
		return v

def mean(l) :
	return reduce(lambda x,y: x+y, l) / float(len(l))

class PID(object) :
	def __init__(self, temp_probe, target) :
		self.temp_probe = temp_probe
		self.samples = []
		self.target = target
		GPIO.setup(CHILLPIN, GPIO.OUT)

		self.pid_ts = None
		self.events = []
		GPIO.output(CHILLPIN, False)

		self.fPeriod = 300.0
		self.fMinOff = 60.0 * 3
		assert self.fPeriod > self.fMinOff

		# pid state
		self.fError = None
		self.fIError = None
		self.fDError = None
		self.fPriorError = None

		self.fPID = None

		# guesstimated PID constants. ratio, not percentage based.
		self.fKP = 0.02
		self.fKI = 0.002
		self.fKD = 0.0

	@property
	def state(self) :
		return {
			'kp' : nv(self.fKP),
			'ki' : nv(self.fKI),
			'kd' : nv(self.fKD),
			'err' : nv(self.fError),	
			'ierr' : nv(self.fIError),
			'derr' : nv(self.fDError),
			'pid' : nv(self.fPID)
		}

	def step(self) :
		now = time.time()
		self.samples.append(self.temp_probe.read())
		if self.pid_ts is None or self.pid_ts < now - self.fPeriod :
			self.pid_ts = now
			self.fTemp = mean(self.samples)
			self.samples = []

			# This is the error we want to reduce to 0. Positive values mean it is too warm.
			self.fError = self.fTemp - self.target
			print 'err: %f' % self.fError
			
			# figure out proportion to use, start at 0
			self.fPID = 0.0

			# apply proportional...
			self.fPID += self.fKP * self.fError

			# to degree-minutes
			self.fIError += (self.fError * self.fPeriod) / 60.0

			# apply integral...
			self.fPID += self.fKI * self.fIError

			if self.fPriorError is not None :
				self.fDError = ((self.fError - self.fPriorError) * 60.0) / self.fPeriod
			self.fPriorError = self.fError

			# if we've got a derivative... apply it
			if self.fDError is not None :
				self.fPID += self.fKD * self.fDError
		
			print time.ctime(), 'PID output: %f' % self.fPID

			if self.fPID * self.fPeriod < 30.0 :
				# nope, it's less than 1%. just turn it off and leave it that way until next time
				self.events.append((now, False))
				print time.ctime(), 'no chilling, pid output way low. just turning off'
			else :
				off_sec = (1.0 - self.fPID) * self.fPeriod
				off_sec = max(off_sec, self.fMinOff) # 3 minute minimum to be off
				on_sec = self.fPeriod - off_sec

				self.events.append((now, True))
				self.events.append((now + on_sec, False))
				print time.ctime(), 'scheduled on/off events for pid output. on for %f, off for %f' % (on_sec, off_sec)

		kept_events = []
		for event in self.events :
			ts,val = event
			if ts <= now :
				print time.ctime(), 'set chiller: %f' % val
				GPIO.output(CHILLPIN, val)
			else :
				kept_events.append(event)
		
		self.events = kept_events

class ChillmonBot(mediorc.IRC) :
	def __init__(self, server, nick, chan, temp_probes, pid, zmqpub=None) :
		self.temp_probes = temp_probes
		self.pid = pid
		self.zmqpub = zmqpub
		mediorc.IRC.__init__(self, server, nick, chan)

	def on_pubmsg(self, c, e) :
		chan = e.target()
		words = e.arguments()[0].split(' ')

		msg = None
		if words[0] == '!temp' :
			msg = 'temperatures: %s' % (', '.join(['%s: %0.1f F' % (name, probe.read()) for name,probe in self.temp_probes.items()]))

		if msg :
			self.connection.privmsg(chan, msg)

	def do_work(self) :
		if self.zmqpub :
			self.zmqpub.send({
				'temps' : dict([(k,v.read()) for k,v in self.temp_probes.items()] + [('target', self.pid.target)]),
				'pidstate' : self.pid.state
			})
		self.pid.step()

class ChillmonBotThread(mediorc.IRCThread) :
	def __init__(self, server, nick, chan, temperature_probes, pid, zmqpub=None) :
		self.bot_create = lambda: ChillmonBot(server, nick, chan, temperature_probes, pid, zmqpub=zmqpub)
		mediorc.IRCThread.__init__(self)

if __name__ == '__main__' :
	a2d = mcp3008.MCP3008(3300.0)
	beer = mcp3008.TMP36(mcp3008.TMP36.F)
	a2d.setup_channel(0, beer)
	room = mcp3008.TMP36(mcp3008.TMP36.F)
	a2d.setup_channel(1, room)
	beertop = mcp3008.TMP36(mcp3008.TMP36.F)
	a2d.setup_channel(2, beertop)

	zmqpub = None
	try :
		url = sys.argv[4]
		import zmqsub
		zmqpub = zmqsub.JSONZMQBindPub(url)
	except IndexError :
		pass

	temp_probes = {'beer' : beer, 'room' : room, 'beertop' : beertop}
	pid = PID(beer, 67.0) # TODO configuration system for what temp to stick to

	chill = ChillmonBotThread(sys.argv[1], sys.argv[2], sys.argv[3], temp_probes, pid, zmqpub=zmqpub)
	chill.run()
